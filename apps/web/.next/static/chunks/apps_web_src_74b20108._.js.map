{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/tcosentino/projects/nonna.fm/apps/web/src/lib/auth/crypto.ts"],"sourcesContent":["import { AES, enc } from \"crypto-js\";\n\nconst ENCRYPTION_KEY_STORAGE = \"encryption_key\";\nconst STATE_STORAGE = \"spotify_auth_state\";\n\n// We'll generate this key on app start and keep it in memory and localStorage\n// This provides a basic level of encryption for the current session\nlet ENCRYPTION_KEY: string;\n\nexport function initializeEncryption(): void {\n  // Try to get existing key from localStorage\n  const storedKey = localStorage.getItem(ENCRYPTION_KEY_STORAGE);\n  if (storedKey) {\n    ENCRYPTION_KEY = storedKey;\n  } else {\n    // Generate new key if none exists\n    ENCRYPTION_KEY = generateRandomString(32);\n    localStorage.setItem(ENCRYPTION_KEY_STORAGE, ENCRYPTION_KEY);\n  }\n}\n\nexport function encrypt(text: string): string {\n  if (!ENCRYPTION_KEY) {\n    throw new Error(\"Encryption not initialized\");\n  }\n  return AES.encrypt(text, ENCRYPTION_KEY).toString();\n}\n\nexport function decrypt(ciphertext: string): string {\n  if (!ENCRYPTION_KEY) {\n    initializeEncryption(); // Try to initialize if not already done\n  }\n  const bytes = AES.decrypt(ciphertext, ENCRYPTION_KEY);\n  return bytes.toString(enc.Utf8);\n}\n\nexport function generateRandomString(length: number): string {\n  const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const values = crypto.getRandomValues(new Uint8Array(length));\n  return values.reduce((acc, x) => acc + possible[x % possible.length], \"\");\n}\n\n// For PKCE\nexport async function generateCodeChallenge(codeVerifier: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(codeVerifier);\n  const digest = await crypto.subtle.digest(\"SHA-256\", data);\n\n  return btoa(String.fromCharCode(...new Uint8Array(digest)))\n    .replace(/=/g, \"\")\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\");\n}\n\nexport function clearEncryption(): void {\n  ENCRYPTION_KEY = \"\";\n  localStorage.removeItem(ENCRYPTION_KEY_STORAGE);\n  localStorage.removeItem(STATE_STORAGE);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;AAEA,MAAM,yBAAyB;AAC/B,MAAM,gBAAgB;AAEtB,8EAA8E;AAC9E,oEAAoE;AACpE,IAAI;AAEG,SAAS;IACd,4CAA4C;IAC5C,MAAM,YAAY,aAAa,OAAO,CAAC;IACvC,IAAI,WAAW;QACb,iBAAiB;IACnB,OAAO;QACL,kCAAkC;QAClC,iBAAiB,qBAAqB;QACtC,aAAa,OAAO,CAAC,wBAAwB;IAC/C;AACF;AAEO,SAAS,QAAQ,IAAY;IAClC,IAAI,CAAC,gBAAgB;QACnB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,wMAAG,CAAC,OAAO,CAAC,MAAM,gBAAgB,QAAQ;AACnD;AAEO,SAAS,QAAQ,UAAkB;IACxC,IAAI,CAAC,gBAAgB;QACnB,wBAAwB,wCAAwC;IAClE;IACA,MAAM,QAAQ,wMAAG,CAAC,OAAO,CAAC,YAAY;IACtC,OAAO,MAAM,QAAQ,CAAC,wMAAG,CAAC,IAAI;AAChC;AAEO,SAAS,qBAAqB,MAAc;IACjD,MAAM,WAAW;IACjB,MAAM,SAAS,OAAO,eAAe,CAAC,IAAI,WAAW;IACrD,OAAO,OAAO,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,QAAQ,CAAC,IAAI,SAAS,MAAM,CAAC,EAAE;AACxE;AAGO,eAAe,sBAAsB,YAAoB;IAC9D,MAAM,UAAU,IAAI;IACpB,MAAM,OAAO,QAAQ,MAAM,CAAC;IAC5B,MAAM,SAAS,MAAM,OAAO,MAAM,CAAC,MAAM,CAAC,WAAW;IAErD,OAAO,KAAK,OAAO,YAAY,IAAI,IAAI,WAAW,UAC/C,OAAO,CAAC,MAAM,IACd,OAAO,CAAC,OAAO,KACf,OAAO,CAAC,OAAO;AACpB;AAEO,SAAS;IACd,iBAAiB;IACjB,aAAa,UAAU,CAAC;IACxB,aAAa,UAAU,CAAC;AAC1B","debugId":null}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///Users/tcosentino/projects/nonna.fm/apps/web/src/lib/auth/constants.ts"],"sourcesContent":["export const AUTH_STORAGE_KEYS = {\n  SOURCE: {\n    TOKEN: \"nonna_source_token\",\n    STATE: \"nonna_source_state\",\n    SERVICE: \"nonna_source_service\",\n    CODE_VERIFIER: \"nonna_source_code_verifier\",\n  },\n  TARGET: {\n    TOKEN: \"nonna_target_token\",\n    STATE: \"nonna_target_state\",\n    SERVICE: \"nonna_target_service\",\n    CODE_VERIFIER: \"nonna_target_code_verifier\",\n  },\n} as const;\n\nexport interface AuthData {\n  accessToken: string;\n  refreshToken?: string;\n  expiresIn: number;\n  timestamp: number;\n  userId: string;\n  tokenType: string;\n  role: \"source\" | \"target\";\n  serviceId: string;\n}\n\n// Helper functions for managing auth storage\nexport function getAuthData(role: \"source\" | \"target\"): AuthData | null {\n  const key = role === \"source\" ? AUTH_STORAGE_KEYS.SOURCE.TOKEN : AUTH_STORAGE_KEYS.TARGET.TOKEN;\n  const data = localStorage.getItem(key);\n  return data ? JSON.parse(data) : null;\n}\n\nexport function setAuthData(role: \"source\" | \"target\", data: AuthData): void {\n  const key = role === \"source\" ? AUTH_STORAGE_KEYS.SOURCE.TOKEN : AUTH_STORAGE_KEYS.TARGET.TOKEN;\n  localStorage.setItem(key, JSON.stringify(data));\n}\n\nexport function clearAuthData(role: \"source\" | \"target\"): void {\n  const keys = role === \"source\" ? AUTH_STORAGE_KEYS.SOURCE : AUTH_STORAGE_KEYS.TARGET;\n  Object.values(keys).forEach(key => localStorage.removeItem(key));\n}\n\nexport function getServiceType(role: \"source\" | \"target\"): string {\n  const key =\n    role === \"source\" ? AUTH_STORAGE_KEYS.SOURCE.SERVICE : AUTH_STORAGE_KEYS.TARGET.SERVICE;\n  const serviceType = localStorage.getItem(key);\n\n  if (!serviceType) {\n    throw new Error(`No service type found for role: ${role}`);\n  }\n\n  return serviceType;\n}\n\nexport function setServiceType(role: \"source\" | \"target\", serviceId: string): void {\n  const key =\n    role === \"source\" ? AUTH_STORAGE_KEYS.SOURCE.SERVICE : AUTH_STORAGE_KEYS.TARGET.SERVICE;\n  localStorage.setItem(key, serviceId);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAO,MAAM,oBAAoB;IAC/B,QAAQ;QACN,OAAO;QACP,OAAO;QACP,SAAS;QACT,eAAe;IACjB;IACA,QAAQ;QACN,OAAO;QACP,OAAO;QACP,SAAS;QACT,eAAe;IACjB;AACF;AAcO,SAAS,YAAY,IAAyB;IACnD,MAAM,MAAM,SAAS,WAAW,kBAAkB,MAAM,CAAC,KAAK,GAAG,kBAAkB,MAAM,CAAC,KAAK;IAC/F,MAAM,OAAO,aAAa,OAAO,CAAC;IAClC,OAAO,OAAO,KAAK,KAAK,CAAC,QAAQ;AACnC;AAEO,SAAS,YAAY,IAAyB,EAAE,IAAc;IACnE,MAAM,MAAM,SAAS,WAAW,kBAAkB,MAAM,CAAC,KAAK,GAAG,kBAAkB,MAAM,CAAC,KAAK;IAC/F,aAAa,OAAO,CAAC,KAAK,KAAK,SAAS,CAAC;AAC3C;AAEO,SAAS,cAAc,IAAyB;IACrD,MAAM,OAAO,SAAS,WAAW,kBAAkB,MAAM,GAAG,kBAAkB,MAAM;IACpF,OAAO,MAAM,CAAC,MAAM,OAAO,CAAC,CAAA,MAAO,aAAa,UAAU,CAAC;AAC7D;AAEO,SAAS,eAAe,IAAyB;IACtD,MAAM,MACJ,SAAS,WAAW,kBAAkB,MAAM,CAAC,OAAO,GAAG,kBAAkB,MAAM,CAAC,OAAO;IACzF,MAAM,cAAc,aAAa,OAAO,CAAC;IAEzC,IAAI,CAAC,aAAa;QAChB,MAAM,IAAI,MAAM,AAAC,mCAAuC,OAAL;IACrD;IAEA,OAAO;AACT;AAEO,SAAS,eAAe,IAAyB,EAAE,SAAiB;IACzE,MAAM,MACJ,SAAS,WAAW,kBAAkB,MAAM,CAAC,OAAO,GAAG,kBAAkB,MAAM,CAAC,OAAO;IACzF,aAAa,OAAO,CAAC,KAAK;AAC5B","debugId":null}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///Users/tcosentino/projects/nonna.fm/apps/web/src/lib/services/spotify/auth.ts"],"sourcesContent":["import {\n  encrypt,\n  decrypt,\n  generateRandomString,\n  generateCodeChallenge,\n  initializeEncryption,\n} from \"@/lib/auth/crypto\";\nimport {\n  AUTH_STORAGE_KEYS,\n  AuthData,\n  setAuthData,\n  getAuthData,\n  clearAuthData,\n  setServiceType,\n} from \"@/lib/auth/constants\";\n\nconst SOURCE_SPOTIFY_SCOPES = [\n  \"playlist-read-private\",\n  \"playlist-read-collaborative\",\n  \"user-library-read\",\n];\n\nconst TARGET_SPOTIFY_SCOPES = [\n  \"playlist-read-private\",\n  \"playlist-read-collaborative\",\n  \"user-library-read\",\n  \"playlist-modify-public\",\n  \"playlist-modify-private\",\n  \"user-library-modify\",\n];\n\ninterface SpotifyTokenResponse {\n  access_token: string;\n  token_type: string;\n  expires_in: number;\n  refresh_token: string;\n  scope: string;\n}\n\nasync function fetchSpotifyUserProfile(accessToken: string): Promise<{ id: string }> {\n  try {\n    const response = await fetch(\"https://api.spotify.com/v1/me\", {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch user profile\");\n    }\n\n    const data = await response.json();\n    return {\n      id: data.id,\n    };\n  } catch (error) {\n    console.error(\"Error fetching user profile:\", error);\n    throw error;\n  }\n}\n\nexport async function initiateSpotifyAuth(role: \"source\" | \"target\"): Promise<void> {\n  initializeEncryption();\n\n  // Clear any existing auth data for this role\n  clearAuthData(role);\n\n  const state = {\n    value: generateRandomString(16),\n    role,\n  };\n\n  const codeVerifier = generateRandomString(64);\n  const codeChallenge = await generateCodeChallenge(codeVerifier);\n\n  // Store state and code verifier\n  const stateKey =\n    role === \"source\" ? AUTH_STORAGE_KEYS.SOURCE.STATE : AUTH_STORAGE_KEYS.TARGET.STATE;\n  const verifierKey =\n    role === \"source\"\n      ? AUTH_STORAGE_KEYS.SOURCE.CODE_VERIFIER\n      : AUTH_STORAGE_KEYS.TARGET.CODE_VERIFIER;\n\n  try {\n    localStorage.setItem(stateKey, encrypt(JSON.stringify(state)));\n    document.cookie = `${verifierKey}=${codeVerifier}; path=/; max-age=3600; SameSite=Lax`;\n  } catch (error) {\n    console.error(\"Failed to store auth data:\", error);\n    throw new Error(\"Failed to initialize authentication\");\n  }\n\n  const scopes = role === \"source\" ? SOURCE_SPOTIFY_SCOPES : TARGET_SPOTIFY_SCOPES;\n\n  const params = new URLSearchParams({\n    client_id: process.env.NEXT_PUBLIC_SPOTIFY_CLIENT_ID || \"\",\n    response_type: \"code\",\n    redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}/callback/spotify`,\n    state: JSON.stringify(state),\n    scope: scopes.join(\" \"),\n    code_challenge_method: \"S256\",\n    code_challenge: codeChallenge,\n    show_dialog: \"true\",\n  });\n\n  window.location.href = `https://accounts.spotify.com/authorize?${params.toString()}`;\n}\n\nexport async function handleSpotifyCallback(\n  searchParams: string\n): Promise<{ success: boolean; role?: \"source\" | \"target\" }> {\n  console.log(\"Starting Spotify callback handling in auth.ts...\");\n\n  // Initialize encryption before handling callback\n  initializeEncryption();\n\n  if (!searchParams) {\n    console.error(\"No search params provided\");\n    return { success: false };\n  }\n\n  const params = new URLSearchParams(searchParams);\n  const code = params.get(\"code\");\n  const receivedState = params.get(\"state\");\n  const error = params.get(\"error\");\n\n  console.log(\"Received params:\", {\n    hasCode: !!code,\n    hasState: !!receivedState,\n    error: error || \"none\",\n  });\n\n  if (error) {\n    console.error(\"Spotify auth error:\", error);\n    return { success: false };\n  }\n\n  // Verify state\n  let storedState: { role: \"source\" | \"target\" } | null = null;\n  try {\n    const encryptedState =\n      localStorage.getItem(AUTH_STORAGE_KEYS.SOURCE.STATE) ||\n      localStorage.getItem(AUTH_STORAGE_KEYS.TARGET.STATE);\n    if (encryptedState) {\n      storedState = JSON.parse(decrypt(encryptedState));\n    }\n  } catch (error) {\n    console.error(\"Failed to decrypt stored state:\", error);\n    return { success: false };\n  }\n\n  if (!storedState || !receivedState) {\n    console.error(\"State missing\", {\n      hasStoredState: !!storedState,\n      hasReceivedState: !!receivedState,\n    });\n    return { success: false };\n  }\n\n  try {\n    const parsedReceivedState = JSON.parse(receivedState);\n    if (parsedReceivedState.role !== storedState.role) {\n      console.error(\"State role mismatch\");\n      return { success: false };\n    }\n  } catch (error) {\n    console.error(\"Failed to parse received state:\", error);\n    return { success: false };\n  }\n\n  // Get stored code verifier from cookies\n  let codeVerifier: string | null = null;\n  try {\n    const cookies = document.cookie.split(\";\");\n    const verifierKey =\n      storedState.role === \"source\"\n        ? AUTH_STORAGE_KEYS.SOURCE.CODE_VERIFIER\n        : AUTH_STORAGE_KEYS.TARGET.CODE_VERIFIER;\n    const verifierCookie = cookies.find(cookie => cookie.trim().startsWith(`${verifierKey}=`));\n    if (verifierCookie) {\n      // Extract everything after the equals sign, properly handling URL encoding\n      codeVerifier = decodeURIComponent(verifierCookie.split(\"=\")[1].trim());\n    }\n  } catch (error) {\n    console.error(\"Failed to get code verifier from cookies:\", error);\n    return { success: false };\n  }\n\n  if (!codeVerifier || !code) {\n    console.error(\"Missing verifier or code\", {\n      hasCodeVerifier: !!codeVerifier,\n      hasCode: !!code,\n    });\n    return { success: false };\n  }\n\n  console.log(\"State and verifier validation successful\");\n\n  // Exchange code for token with retry logic\n  console.log(\"Exchanging code for token...\");\n  let tokenResponse: Response | undefined;\n  let retryCount = 0;\n  const maxRetries = 3;\n  const backoffMs = 1000; // Start with 1 second delay\n\n  while (retryCount < maxRetries) {\n    try {\n      tokenResponse = await fetch(\"https://accounts.spotify.com/api/token\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n        },\n        body: new URLSearchParams({\n          client_id: process.env.NEXT_PUBLIC_SPOTIFY_CLIENT_ID || \"\",\n          grant_type: \"authorization_code\",\n          code,\n          redirect_uri: process.env.NEXT_PUBLIC_SPOTIFY_REDIRECT_URI || \"\",\n          code_verifier: codeVerifier,\n        }),\n      });\n\n      if (tokenResponse.ok) {\n        break;\n      }\n\n      const errorText = await tokenResponse.text();\n      console.warn(`Token exchange attempt ${retryCount + 1} failed:`, {\n        status: tokenResponse.status,\n        statusText: tokenResponse.statusText,\n        error: errorText,\n      });\n\n      // If we get a 400 error, the code might be invalid/expired - no point retrying\n      if (tokenResponse.status === 400) {\n        console.error(\"Token exchange failed with 400 - code might be invalid or expired\");\n        return { success: false };\n      }\n\n      retryCount++;\n      if (retryCount < maxRetries) {\n        console.log(`Retrying in ${backoffMs / 1000} seconds...`);\n        await new Promise(resolve => setTimeout(resolve, backoffMs * retryCount));\n      }\n    } catch (error) {\n      console.error(`Network error during token exchange attempt ${retryCount + 1}:`, error);\n      retryCount++;\n      if (retryCount < maxRetries) {\n        console.log(`Retrying in ${backoffMs / 1000} seconds...`);\n        await new Promise(resolve => setTimeout(resolve, backoffMs * retryCount));\n      } else {\n        console.error(\"Max retries reached for token exchange\");\n        return { success: false };\n      }\n    }\n  }\n\n  if (!tokenResponse || !tokenResponse.ok) {\n    console.error(\"All token exchange attempts failed\");\n    return { success: false };\n  }\n\n  console.log(\"Token exchange successful\");\n  let tokenData: SpotifyTokenResponse;\n  try {\n    tokenData = await tokenResponse.json();\n  } catch (error) {\n    console.error(\"Failed to parse token response:\", error);\n    return { success: false };\n  }\n\n  // Clear state and verifier\n  clearAuthData(storedState.role);\n\n  // Store auth data\n  try {\n    // Fetch user profile\n    const userProfile = await fetchSpotifyUserProfile(tokenData.access_token);\n\n    const authData: AuthData = {\n      accessToken: tokenData.access_token,\n      refreshToken: tokenData.refresh_token,\n      expiresIn: tokenData.expires_in,\n      timestamp: Date.now(),\n      userId: userProfile.id,\n      tokenType: tokenData.token_type,\n      role: storedState.role,\n      serviceId: \"spotify\",\n    };\n\n    setAuthData(storedState.role, authData);\n    setServiceType(storedState.role, \"spotify\");\n    return { success: true, role: storedState.role };\n  } catch (error) {\n    console.error(\"Failed to store auth data:\", error);\n    return { success: false };\n  }\n}\n\nexport async function getSpotifyAuthData(role: \"source\" | \"target\"): Promise<AuthData | null> {\n  if (typeof window === \"undefined\") return null;\n\n  const authData = getAuthData(role);\n  if (!authData || authData.serviceId !== \"spotify\") {\n    return null;\n  }\n\n  // Check if token is expired or will expire in less than 5 minutes\n  const expirationTime = authData.timestamp + authData.expiresIn * 1000;\n  const now = Date.now();\n  const timeToExpiry = expirationTime - now;\n\n  if (timeToExpiry <= 300000 && authData.refreshToken) {\n    // 5 minutes in milliseconds\n    return refreshSpotifyToken(authData.refreshToken, role);\n  }\n\n  return authData;\n}\n\nexport async function refreshSpotifyToken(\n  refreshToken: string,\n  role: \"source\" | \"target\",\n  directRequest = false\n): Promise<AuthData | null> {\n  try {\n    if (!refreshToken || refreshToken.trim() === \"\") {\n      throw new Error(\"Empty refresh token provided\");\n    }\n\n    console.log(\"Attempting to refresh token with refresh token length:\", refreshToken?.length);\n\n    let responseData;\n    // Get existing auth data to preserve user info\n    const existingAuthData = getAuthData(role);\n\n    // For test environments, allow direct requests to Spotify API\n    if (directRequest) {\n      const clientId = process.env.NEXT_PUBLIC_SPOTIFY_CLIENT_ID;\n      const clientSecret = process.env.SPOTIFY_CLIENT_SECRET;\n\n      if (!clientId || !clientSecret) {\n        throw new Error(\"Missing Spotify client credentials\");\n      }\n\n      // Create Basic Auth header\n      const buffer = Buffer.from(`${clientId}:${clientSecret}`);\n      const base64Auth = buffer.toString(\"base64\");\n\n      const response = await fetch(\"https://accounts.spotify.com/api/token\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n          Authorization: `Basic ${base64Auth}`,\n        },\n        body: new URLSearchParams({\n          grant_type: \"refresh_token\",\n          refresh_token: refreshToken,\n          client_id: clientId,\n        }).toString(),\n      });\n\n      if (!response.ok) {\n        console.error(\"Direct Spotify API request failed:\", response.status, response.statusText);\n        return null;\n      }\n\n      responseData = await response.json();\n    } else {\n      // Use our server API endpoint (default approach)\n      const refreshUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/spotify/refresh`;\n\n      const response = await fetch(refreshUrl, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ refreshToken }),\n      });\n\n      try {\n        responseData = await response.json();\n      } catch (error) {\n        console.error(\"Failed to parse response as JSON:\", error);\n        return null;\n      }\n\n      if (!response.ok) {\n        console.error(\"Failed to refresh token:\", response.status, response.statusText);\n        console.error(\"Error details:\", responseData);\n        return null;\n      }\n    }\n\n    if (!responseData.access_token) {\n      console.error(\"Invalid token response - missing access_token:\", responseData);\n      return null;\n    }\n\n    const authData: AuthData = {\n      accessToken: responseData.access_token,\n      refreshToken: responseData.refresh_token || refreshToken, // Use old refresh token if new one is not provided\n      expiresIn: responseData.expires_in,\n      timestamp: Date.now(),\n      userId: existingAuthData?.userId || \"\",\n      tokenType: responseData.token_type || \"Bearer\",\n      role: role,\n      serviceId: \"spotify\",\n    };\n\n    setAuthData(role, authData);\n    return authData;\n  } catch (error) {\n    console.error(\"Error refreshing token:\", error);\n    return null;\n  }\n}\n\nexport function clearSpotifyAuth(role?: \"source\" | \"target\"): void {\n  if (role) {\n    clearAuthData(role);\n  } else {\n    clearAuthData(\"source\");\n    clearAuthData(\"target\");\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 517, "column": 0}, "map": {"version":3,"sources":["file:///Users/tcosentino/projects/nonna.fm/apps/web/src/app/callback/spotify/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { handleSpotifyCallback } from \"@/lib/services/spotify/auth\";\nimport { useRouter, useSearchParams } from \"next/navigation\";\nimport { useEffect } from \"react\";\nimport { getServiceType } from \"@/lib/auth/constants\";\nimport { Suspense } from \"react\";\n\nfunction SpotifyCallbackContent() {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n\n  useEffect(() => {\n    const handleCallback = async (): Promise<void> => {\n      try {\n        // Get the raw search string from the URL\n        const searchString = searchParams.toString();\n\n        // Handle the callback and get the result\n        const { success, role } = await handleSpotifyCallback(searchString);\n\n        console.log(\"Callback result:\", success, role);\n\n        if (!success) {\n          console.error(\"Failed to handle Spotify callback\");\n          router.push(\"/\");\n          return;\n        }\n\n        // Get service types for both source and target\n        const sourceService = getServiceType(\"source\");\n\n        // For target role, ensure we have a source service\n        if (role === \"target\" && !sourceService) {\n          console.error(\"Cannot redirect to transfer: no source service configured\");\n          router.push(\"/\");\n          return;\n        }\n\n        // Build redirect URL with service parameters\n        const redirectUrl =\n          role === \"target\" ? `/library/${sourceService}/spotify` : `/source?source=spotify`;\n\n        console.log(\"Redirecting to:\", redirectUrl);\n        router.push(redirectUrl);\n      } catch (error) {\n        console.error(\"Error during Spotify callback:\", error);\n        router.push(\"/\");\n      }\n    };\n\n    handleCallback();\n  }, [searchParams, router]);\n\n  // Return null while the effect is running\n  return null;\n}\n\nexport default function SpotifyCallback() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <SpotifyCallbackContent />\n    </Suspense>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;;;AALA;;;;;;AAQA,SAAS;;IACP,MAAM,SAAS,IAAA,iWAAS;IACxB,MAAM,eAAe,IAAA,uWAAe;IAEpC,IAAA,yXAAS;4CAAC;YACR,MAAM;mEAAiB;oBACrB,IAAI;wBACF,yCAAyC;wBACzC,MAAM,eAAe,aAAa,QAAQ;wBAE1C,yCAAyC;wBACzC,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,MAAM,IAAA,oLAAqB,EAAC;wBAEtD,QAAQ,GAAG,CAAC,oBAAoB,SAAS;wBAEzC,IAAI,CAAC,SAAS;4BACZ,QAAQ,KAAK,CAAC;4BACd,OAAO,IAAI,CAAC;4BACZ;wBACF;wBAEA,+CAA+C;wBAC/C,MAAM,gBAAgB,IAAA,mKAAc,EAAC;wBAErC,mDAAmD;wBACnD,IAAI,SAAS,YAAY,CAAC,eAAe;4BACvC,QAAQ,KAAK,CAAC;4BACd,OAAO,IAAI,CAAC;4BACZ;wBACF;wBAEA,6CAA6C;wBAC7C,MAAM,cACJ,SAAS,WAAW,AAAC,YAAyB,OAAd,eAAc,cAAa;wBAE7D,QAAQ,GAAG,CAAC,mBAAmB;wBAC/B,OAAO,IAAI,CAAC;oBACd,EAAE,OAAO,OAAO;wBACd,QAAQ,KAAK,CAAC,kCAAkC;wBAChD,OAAO,IAAI,CAAC;oBACd;gBACF;;YAEA;QACF;2CAAG;QAAC;QAAc;KAAO;IAEzB,0CAA0C;IAC1C,OAAO;AACT;GAhDS;;QACQ,iWAAS;QACH,uWAAe;;;KAF7B;AAkDM,SAAS;IACtB,qBACE,4YAAC,wXAAQ;QAAC,wBAAU,4YAAC;sBAAI;;;;;;kBACvB,cAAA,4YAAC;;;;;;;;;;AAGP;MANwB","debugId":null}}]
}